#include "../types.h"
#define __MOUSE_DRIVE__
#include "mouse.h"
#include "../screen.h"
#include "../i386.h"
#include "../waresdes.h"
#include "../varswords.h"

#define PS2_CMD_PORT     0x64
#define PS2_DATA_PORT    0x60
#define ENABLE_AUX_DEV   0xA8
#define WRITE_TO_MOUSE   0xD4

u8 MOUSE_DATA_PS2[3];
int keycodes_validos[] = {
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A,
    0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14,
    0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E,
    0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
    0x29, 0x2A, 0x2B, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34,
    0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E,
    0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
    0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52,
    0x53, 0x57, 0x58
};
int select_all = 0;
int salve_file = 0;
int copy_ = 0;
int colar_ = 0;
int maiuscolo = 1;
int new_key = 0;
int in_wi = 0;
int MouseX = 100;
int MouseY = 100;
int MouseBTNClick = 0;
int MOUSE_TYPE = 0;
int MouseCursorIMGN = 0;
int setClickInfiniteDireito = 0;
int click_infinite = 0;
char key;

void update_mouse_position(int dx, int dy, int left, int right, int middle) {
    MouseX += dx;
    MouseY += dy;

    // Limites da tela (ajuste conforme sua resolução)
    if (MouseX < 0) MouseX = 0;
    if (MouseY < 0) MouseY = 0;
    if (MouseX > 799) MouseX = 799;
    if (MouseY > 599) MouseY = 599;

    // Se quiser desenhar o cursor na tela aqui:
    // draw_mouse(MouseX, MouseY);
	MouseBTNClick = 0;
    // Se quiser testar clique:
    if (left) {
        // Código para clique esquerdo
        MouseBTNClick = 1;
    }
    if (right) {
        // Código para clique direito
        MouseBTNClick = 2;
    }
    if (middle) {
        // Código para clique do meio
        MouseBTNClick = 3;
    }
}
// Imagem do cursor (bitmap de 11x19 pixels)
u8 MOUSE_CURSOR_[11 * 19 * 4 + 2] = {
    11,19,
    0x01,0x01,0x01,/**/0x01,0x01,0x01,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/
    0x01,0x01,0x01,/**/0x86,0x86,0x86,/**/0x01,0x01,0x01,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/
    0x01,0x01,0x01,/**/0x86,0x86,0x86,/**/0x96,0x96,0x96,/**/0x01,0x01,0x01,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/
    0x01,0x01,0x01,/**/0x96,0x96,0x96,/**/0x96,0x96,0x96,/**/0xA6,0xA6,0xA6,/**/0x01,0x01,0x01,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/
    0x01,0x01,0x01,/**/0xA6,0xA6,0xA6,/**/0xA6,0xA6,0xA6,/**/0xA6,0xA6,0xA6,/**/0xA6,0xA6,0xA6,/**/0x01,0x01,0x01,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/
    0x01,0x01,0x01,/**/0xA6,0xA6,0xA6,/**/0xA6,0xA6,0xA6,/**/0xA6,0xA6,0xA6,/**/0xA6,0xA6,0xA6,/**/0xc6,0xc6,0xc6,/**/0x01,0x01,0x01,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/
    0x01,0x01,0x01,/**/0xA6,0xA6,0xA6,/**/0xB6,0xB6,0xB6,/**/0xC6,0xC6,0xC6,/**/0xD6,0xD6,0xC6,/**/0xD6,0xD6,0xD6,/**/0xD6,0xD6,0xD6,/**/0x01,0x01,0x01,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/
    0x01,0x01,0x01,/**/0xA6,0xA6,0xA6,/**/0xB6,0xB6,0xB6,/**/0xC6,0xC6,0xC6,/**/0xC6,0xC6,0xC6,/**/0xE6,0xE6,0xE6,/**/0xE6,0xE6,0xE6,/**/0xF6,0xF6,0xE6,/**/0x01,0x01,0x01,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/
    0x01,0x01,0x01,/**/0xA6,0xA6,0xA6,/**/0xB6,0xB6,0xB6,/**/0xC6,0xC6,0xC6,/**/0xC6,0xC6,0xC6,/**/0xC6,0xC6,0xC6,/**/0xE6,0xE6,0xE6,/**/0xF6,0xF6,0xF6,/**/0xF6,0xF6,0xF6,/**/0x01,0x01,0x01,/**/0x00,0x00,0x00,/**/
    0x01,0x01,0x01,/**/0xA6,0xA6,0xA6,/**/0xA6,0xA6,0xA6,/**/0xC6,0xC6,0xC6,/**/0xC6,0xC6,0xC6,/**/0xC6,0xC6,0xC6,/**/0x01,0x01,0x01,/**/0x01,0x01,0x01,/**/0x01,0x01,0x01,/**/0x01,0x01,0x01,/**/0x01,0x01,0x01,/**/
    0x01,0x01,0x01,/**/0x96,0x96,0xA6,/**/0x86,0x86,0x86,/**/0x01,0x01,0x01,/**/0xB6,0xB6,0xB6,/**/0xB6,0xB6,0xB6,/**/0x01,0x01,0x01,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/
    0x01,0x01,0x01,/**/0x86,0x86,0x86,/**/0x01,0x01,0x01,/**/0x00,0x00,0x00,/**/0x01,0x01,0x01,/**/0xB6,0xB6,0xB6,/**/0xB6,0xB6,0xB6,/**/0x01,0x01,0x01,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/
    0x01,0x01,0x01,/**/0x01,0x01,0x01,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x01,0x01,0x01,/**/0xA6,0xA6,0xA6,/**/0xA6,0xA6,0xA6,/**/0x01,0x01,0x01,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/
    0x01,0x01,0x01,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x01,0x01,0x01,/**/0x96,0x96,0x96,/**/0x96,0x96,0x96,/**/0x01,0x01,0x01,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/
    0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x01,0x01,0x01,/**/0x86,0x86,0x86,/**/0x86,0x86,0x86,/**/0x01,0x01,0x01,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/
    0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x01,0x01,0x01,/**/0x86,0x86,0x86,/**/0x86,0x86,0x86,/**/0x01,0x01,0x01,/**/0x00,0x00,0x00,/**/
    0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x01,0x01,0x01,/**/0x86,0x86,0x86,/**/0x86,0x86,0x86,/**/0x01,0x01,0x01,/**/0x00,0x00,0x00,/**/
    0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x01,0x01,0x01,/**/0x01,0x01,0x01,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/
    0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/0x00,0x00,0x00,/**/
    
};

void wait_input() {
    while ((inb(0x64) & 0x02) != 0); // Espera até que o controlador esteja pronto para receber comando
}

void wait_output() {
    while ((inb(0x64) & 0x01) == 0); // Espera até que haja dados disponíveis para leitura
}

void enable_ps2_mouse() {
    // 1. Habilita o segundo canal (mouse) no controlador PS/2
    uint8_t mask;

	mask = inb(0xA1);         // Lê a máscara atual do PIC escravo
	mask &= ~(1 << 4);        // Ativa IRQ12 (bit 4 no escravo)
	outb(mask, 0xA1);         // Escreve de volta
    outb(0x64, 0xA8);   // Enable auxiliary device
    wait_input();

    // 2. Envia comando para encaminhar dados ao mouse
    outb(0x64, 0xD4);   // Tell the controller the next byte is for the mouse
    wait_input();

    // 3. Envia comando de "Enable Data Reporting" para o mouse
    outb(0x60, 0xF4);   // Envia 0xF4 para o mouse (habilita envio de pacotes)
    wait_input();

    // 4. Aguarda resposta do mouse (espera pelo ACK: 0xFA)
    wait_output();
    uint8_t ack = inb(0x60);

    if (ack != 0xFA) {  // 0xFA é o ACK correto do mouse (não 0xF4)
        clear(255,0,0); // Tela vermelha se falhar
        draw();
        for(;;);
    }
}

void disable_ps2_mouse() {
    // Passo 1: Desativa o dispositivo PS/2 secundário (mouse)
    outb(0x64, 0xA7);  // Comando: Disable second PS/2 port (mouse)
	outb(0x60, 0xA7);  // Comando: Disable second PS/2 port (mouse)
    // Passo 2: Ativa o dispositivo PS/2 primário (teclado)
    outb(0x64, 0xAE);  // Comando: Enable first PS/2 port (keyboard)
    outb(0x60, 0xAE);  // Comando: Enable first PS/2 port (keyboard)
    // Passo 3: Opcional - limpa buffer do teclado
    while (inb(0x64) & 0x01) {
        (void)inb(0x60); // descarta dados pendentes
    }
    
}

void read_mouse_packet(u8 packet[3]) {
    int i = 0;
    int timeout = 1000;
    uint8_t ps2_data = 0;
	new_key = 0;
	
    while (i < 3 && timeout > 0) {
    	//wait_input();
    	ps2_data = inb(PS2_CMD_PORT);
    	//outb(0xA0, 0x20); // EOI PIC escravo
		//outb(0x20, 0x20); // EOI PIC mestre
        if (ps2_data & 0x01) {
            if (ps2_data & 0x20) {
                packet[i++] = inb(PS2_DATA_PORT);
                key = 0;
            } else if (ps2_data & 0x1) {
            	//wait_input();
	        	key = inb(0x60);
            	
            }
        }
        timeout--;
    }
    
	new_key = 0;
    while (i < 3) packet[i++] = 0; // Completa com 0 se falhar
    
}

void SetMouseCursorPosition(int x, int y) {
    MouseX = x;
    MouseY = y;
    MouseBTNClick = 0;
}

void SetCursorMouse() {
    SetBITMAP(MOUSE_CURSOR_, MouseX, MouseY);
}
u8 ret_key(u8 key_) {
	if(key_ == 0x1D){
		if(atvCTRL == 1) {
			//return 0xFE;
		} else if(atvCTRL == 0){
			atvCTRL = 1;
			//return 0;
		}
	} else {
		if(atvCTRL == 1) {
			if(key_ == 0x0){
				atvCTRL = 0;
			}
			
		}
	}
	
	if (key_ == 0x2A) { // Shift pressionado
		atvSHFT = 1;
		maiuscolo = 1;
		//return 0;
	}

	if (key_ == 0xAA) { // Shift solto
		atvSHFT = 0;
		maiuscolo = 0;
		//maiuscolo = 0;
		//return 0;
	}

	if (atvSHFT) {
		maiuscolo = 1;
	} else {
		maiuscolo = 0;
	}
	
	if(key_ == 0x1E){
		if(atvA == 1) {
			return 0;
		} else if(atvA == 0){
			atvA = 1;
			return 0x1E;
		}
    } else {
    	if(atvA == 1) {
			atvA = 0;
		}
    }
    
	if(key_ == 0x30){
		if(atvB == 1) {
			return 0;
		} else if(atvB == 0){
			atvB = 1;
			return 0x30;
		}
	} else {
		if(atvB == 1) {
			atvB = 0;
		}
	}
	
    if(key_ == 0x2E){
		if(atvC == 1) {
			return 0;
		} else if(atvC == 0){
			atvC = 1;
			return 0x2E;
		}
	} else {
		if(atvC == 1) {
			atvC = 0;
		}
	}
	
	if(key_ == 0x20){
		if(atvD == 1) {
			return 0;
		} else if(atvD == 0){
			atvD = 1;
			return 0x20;
		}
	} else {
		if(atvD == 1) {
			atvD = 0;
		}
	}
	
	if(key_ == 0x12){
		if(atvE == 1) {
			return 0;
		} else if(atvE == 0){
			atvE = 1;
			return 0x12;
		}
	} else {
		if(atvE == 1) {
			atvE = 0;
		}
	}
	
	if(key_ == 0x21){
		if(atvF == 1) {
			return 0;
		} else if(atvF == 0){
			atvF = 1;
			return 0x21;
		}
	} else {
		if(atvF == 1) {
			atvF = 0;
		}
	}
	
	if(key_ == 0x22){
		if(atvG == 1) {
			return 0;
		} else if(atvG == 0){
			atvG = 1;
			return 0x22;
		}
	} else {
		if(atvG == 1) {
			atvG = 0;
		}
	}

	if(key_ == 0x23){
		if(atvH == 1) {
			return 0;
		} else if(atvH == 0){
			atvH = 1;
			return 0x23;
		}
	} else {
		if(atvH == 1) {
			atvH = 0;
		}
	}

	if(key_ == 0x17){
		if(atvI == 1) {
			return 0;
		} else if(atvI == 0){
			atvI = 1;
			return 0x17;
		}
	} else {
		if(atvI == 1) {
			atvI = 0;
		}
	}

	if(key_ == 0x24){
		if(atvJ == 1) {
			return 0;
		} else if(atvJ == 0){
			atvJ = 1;
			return 0x24;
		}
	} else {
		if(atvJ == 1) {
			atvJ = 0;
		}
	}

	if(key_ == 0x25){
		if(atvK == 1) {
			return 0;
		} else if(atvK == 0){
			atvK = 1;
			return 0x25;
		}
	} else {
		if(atvK == 1) {
			atvK = 0;
		}
	}

	if(key_ == 0x26){
		if(atvL == 1) {
			return 0;
		} else if(atvL == 0){
			atvL = 1;
			return 0x26;
		}
	} else {
		if(atvL == 1) {
			atvL = 0;
		}
	}

	if(key_ == 0x32){
		if(atvM == 1) {
			return 0;
		} else if(atvM == 0){
			atvM = 1;
			return 0x32;
		}
	} else {
		if(atvM == 1) {
			atvM = 0;
		}
	}

	if(key_ == 0x31){
		if(atvN == 1) {
			return 0;
		} else if(atvN == 0){
			atvN = 1;
			return 0x31;
		}
	} else {
		if(atvN == 1) {
			atvN = 0;
		}
	}

	if(key_ == 0x18){
		if(atvO == 1) {
			return 0;
		} else if(atvO == 0){
			atvO = 1;
			return 0x18;
		}
	} else {
		if(atvO == 1) {
			atvO = 0;
		}
	}

	if(key_ == 0x19){
		if(atvP == 1) {
			return 0;
		} else if(atvP == 0){
			atvP = 1;
			return 0x19;
		}
	} else {
		if(atvP == 1) {
			atvP = 0;
		}
	}

	if(key_ == 0x10){
		if(atvQ == 1) {
			return 0;
		} else if(atvQ == 0){
			atvQ = 1;
			return 0x10;
		}
	} else {
		if(atvQ == 1) {
			atvQ = 0;
		}
	}

	if(key_ == 0x13){
		if(atvR == 1) {
			return 0;
		} else if(atvR == 0){
			atvR = 1;
			return 0x13;
		}
	} else {
		if(atvR == 1) {
			atvR = 0;
		}
	}

	if(key_ == 0x1F){
		if(atvS == 1) {
			return 0;
		} else if(atvS == 0){
			atvS = 1;
			return 0x1F;
		}
	} else {
		if(atvS == 1) {
			atvS = 0;
		}
	}

	if(key_ == 0x14){
		if(atvT == 1) {
			return 0;
		} else if(atvT == 0){
			atvT = 1;
			return 0x14;
		}
	} else {
		if(atvT == 1) {
			atvT = 0;
		}
	}

	if(key_ == 0x16){
		if(atvU == 1) {
			return 0;
		} else if(atvU == 0){
			atvU = 1;
			return 0x16;
		}
	} else {
		if(atvU == 1) {
			atvU = 0;
		}
	}

	if(key_ == 0x2F){
		if(atvV == 1) {
			return 0;
		} else if(atvV == 0){
			atvV = 1;
			return 0x2F;
		}
	} else {
		if(atvV == 1) {
			atvV = 0;
		}
	}

	if(key_ == 0x11){
		if(atvW == 1) {
			return 0;
		} else if(atvW == 0){
			atvW = 1;
			return 0x11;
		}
	} else {
		if(atvW == 1) {
			atvW = 0;
		}
	}

	if(key_ == 0x18){
		if(atvX == 1) {
			return 0;
		} else if(atvX == 0){
			atvX = 1;
			return 0x18;
		}
	} else {
		if(atvX == 1) {
			atvX = 0;
		}
	}

	if(key_ == 0x15){
		if(atvY == 1) {
			return 0;
		} else if(atvY == 0){
			atvY = 1;
			return 0x15;
		}
	} else {
		if(atvY == 1) {
			atvY = 0;
		}
	}

	if(key_ == 0x1A){
		if(atvZ == 1) {
			return 0;
		} else if(atvZ == 0){
			atvZ = 1;
			return 0x1A;
		}
	} else {
		if(atvZ == 1) {
			atvZ = 0;
		}
	}
	
	if(key_ == 0x2A){
		if(atvSHFT == 1) {
			return 0;
		} else if(atvSHFT == 0){
			atvSHFT = 1;
			return 0;
		}
	} else {
		if(atvSHFT == 1) {
			atvSHFT = 0;
		}
	}
	
	if (key_ == 0x2A) { // Shift pressionado
		atvSHFT = 1;
		return 0;
	}

	if (key_ == 0xAA) { // Shift solto
		atvSHFT = 0;
		maiuscolo = 0;
		return 0;
	}

	if (atvSHFT) {
		maiuscolo = 1;
	} else {
		maiuscolo = 0;
	}
	
	
	
    return 0;
}



uint8_t mouse_cycle = 0;
uint8_t mouse_packet[3];
void mouse_handler() {
    if (!(inb(0x64) & 0x01)) return;

    uint8_t data = inb(0x60);

    static uint8_t packet[3];
    static uint8_t cycle = 0;

    if (cycle == 0 && !(data & 0x08)) return; // sincronizar

    packet[cycle++] = data;

    if (cycle == 3) {
        cycle = 0;

        int dx = (packet[0] & 0x10) ? (char)packet[1] : packet[1];
        int dy = (packet[0] & 0x20) ? (char)packet[2] : packet[2];
        dy = -dy;

        int left   = (packet[0] & 0x01);
        int right  = (packet[0] & 0x02);
        int middle = (packet[0] & 0x04);

        update_mouse_position(dx, dy, left, right, middle);
    }
}
char MouseUPDate() {
	mouse_handler();
	SetCursorMouse();
	return 0;
}
